# **Лабораторная работа №7**

## Вариант №222

### Доработать программу из лабораторной работы №6 следующим образом:

* Организовать хранение коллекции в реляционной СУБД (`PostgresQL`). Убрать хранение коллекции в файле.
* Для генерации поля id использовать средства базы данных (`sequence`).
* Обновлять состояние коллекции в памяти только при успешном добавлении объекта в БД
* Все команды получения данных должны работать с коллекцией в памяти, а не в БД
* Организовать возможность регистрации и авторизации пользователей. У пользователя есть возможность указать пароль.
* Пароли при хранении хэшировать алгоритмом `SHA-512`
* Запретить выполнение команд не авторизованным пользователям.
* При хранении объектов сохранять информацию о пользователе, который создал этот объект.
* Пользователи должны иметь возможность просмотра всех объектов коллекции, но модифицировать могут только принадлежащие им.
* Для идентификации пользователя отправлять логин и пароль с каждым запросом.

#### Необходимо реализовать многопоточную обработку запросов.

* Для многопоточного чтения запросов использовать `Cached thread pool`
* Для многопотчной обработки полученного запроса использовать `Cached thread pool`
* Для многопоточной отправки ответа использовать `ForkJoinPool`
* Для синхронизации доступа к коллекции использовать синхронизацию чтения и записи с помощью `java.util.concurrent.locks.ReentrantLock`

### Порядок выполнения работы:
1. В качестве базы данных использовать `PostgreSQL.`
2. Для подключения к БД на кафедральном сервере использовать хост `pg`, имя базы данных - `studs`, имя пользователя/пароль совпадают с таковыми для подключения к серверу.

Многопоточность реализована через **корутины**.

# **Лабораторная работа №6**

## Вариант 145

Разделить программу из лабораторной работы №5 на клиентский и серверный модули. Серверный модуль должен осуществлять выполнение команд по управлению коллекцией. Клиентский модуль должен в интерактивном режиме считывать команды, передавать их для выполнения на сервер и выводить результаты выполнения.

## Необходимо выполнить следующие требования:

* Операции обработки объектов коллекции должны быть реализованы с помощью Stream API с использованием лямбда-выражений.
* Объекты между клиентом и сервером должны передаваться в сериализованном виде.
* Объекты в коллекции, передаваемой клиенту, должны быть отсортированы по названию
* Клиент должен корректно обрабатывать временную недоступность сервера.
* Обмен данными между клиентом и сервером должен осуществляться по протоколу TCP
* Для обмена данными на сервере необходимо использовать сетевой канал
* Для обмена данными на клиенте необходимо использовать потоки ввода-вывода
* Сетевые каналы должны использоваться в неблокирующем режиме.

## Обязанности серверного приложения:

* Работа с файлом, хранящим коллекцию.
* Управление коллекцией объектов.
* Назначение автоматически генерируемых полей объектов в коллекции.
* Ожидание подключений и запросов от клиента.
* Обработка полученных запросов (команд).
* Сохранение коллекции в файл при завершении работы приложения.
* Сохранение коллекции в файл при исполнении специальной команды, доступной только серверу (клиент такую команду отправить не может).

## Серверное приложение должно состоять из следующих модулей (реализованных в виде одного или нескольких классов):
* Модуль приёма подключений.
* Модуль чтения запроса.
* Модуль обработки полученных команд.
* Модуль отправки ответов клиенту.

Сервер должен работать в **однопоточном** режиме.

## Обязанности клиентского приложения:
* Чтение команд из консоли.
* Валидация вводимых данных.
* Сериализация введённой команды и её аргументов.
* Отправка полученной команды и её аргументов на сервер.
* Обработка ответа от сервера (вывод результата исполнения команды в консоль).
* Команду save из клиентского приложения необходимо убрать.
* Команда exit завершает работу клиентского приложения.

**Важно!** Команды и их аргументы должны представлять из себя объекты классов. Недопустим обмен "простыми" строками. Так, для команды add или её аналога необходимо сформировать объект, содержащий тип команды и объект, который должен храниться в вашей коллекции.

## Дополнительное задание:
Реализовать логирование различных этапов работы сервера (начало работы, получение нового подключения, получение нового запроса, отправка ответа и т.п.) с помощью `Java Util Logging`

# **Лабораторная работа №5**

## Вариант 1512
Реализовать консольное приложение, которое реализует управление коллекцией объектов в интерактивном режиме. В коллекции необходимо хранить объекты класса `Person`, описание которого приведено ниже.

### Разработанная программа должна удовлетворять следующим требованиям:
* Класс, коллекцией экземпляров которого управляет программа, должен реализовывать сортировку по умолчанию.
* Все требования к полям класса (указанные в виде комментариев) должны быть выполнены.
* Для хранения необходимо использовать коллекцию типа `java.util.LinkedList`
* При запуске приложения коллекция должна автоматически заполняться значениями из файла.
* Имя файла должно передаваться программе с помощью: **переменная окружения**.
* Данные должны храниться в файле в формате `json`
* Чтение данных из файла необходимо реализовать с помощью класса `java.util.Scanner `
* Запись данных в файл необходимо реализовать с помощью класса `java.io.FileOutputStream `
* Все классы в программе должны быть задокументированы в формате `javadoc`.
* Программа должна корректно работать с неправильными данными (ошибки пользовательского ввода, отсутствие прав доступа к файлу и т.п.).

### В интерактивном режиме программа должна поддерживать выполнение следующих команд:
* `help` : вывести справку по доступным командам
* `info` : вывести в стандартный поток вывода информацию о коллекции (тип, дата инициализации, количество элементов и т.д.)
* `show` : вывести в стандартный поток вывода все элементы коллекции в строковом представлении
* `add {element}` : добавить новый элемент в коллекцию
* `update id {element}` : обновить значение элемента коллекции, `id` которого равен заданному
* `remove_by_id id` : удалить элемент из коллекции по его `id`
* `clear` : очистить коллекцию
* `save` : сохранить коллекцию в файл
* `execute_script file_name` : считать и исполнить скрипт из указанного файла. В скрипте содержатся команды в таком же виде, в котором их вводит пользователь в интерактивном режиме.
* `exit` : завершить программу (без сохранения в файл)
* `remove_first` : удалить первый элемент из коллекции
* `shuffle` : перемешать элементы коллекции в случайном порядке
* `history` : вывести последние 10 команд (без их аргументов)
* `max_by_nationality` : вывести любой объект из коллекции, значение поля `nationality` которого является максимальным
* `filter_by_height height` : вывести элементы, значение поля `height` которых равно заданному
* `filter_contains_name name` : вывести элементы, значение поля `name` которых содержит заданную подстроку

### Формат ввода команд:
* Все аргументы команды, являющиеся стандартными типами данных (примитивные типы, классы-оболочки, `String`, классы для хранения дат), должны вводиться в той же строке, что и имя команды.
* Все составные типы данных (объекты классов, хранящиеся в коллекции) должны вводиться по одному полю в строку.
* При вводе составных типов данных пользователю должно показываться приглашение к вводу, содержащее имя поля (например, "Введите дату рождения:")
* Если поле является `enum`'ом, то вводится имя одной из его констант (при этом список констант должен быть предварительно выведен).
* При некорректном пользовательском вводе (введена строка, не являющаяся именем константы в enum'е; введена строка вместо числа; введённое число не входит в указанные границы и т.п.) должно быть показано сообщение об ошибке и предложено повторить ввод поля.
* Для ввода значений `null` использовать пустую строку.
* Поля с комментарием "Значение этого поля должно генерироваться автоматически" не должны вводиться пользователем вручную при добавлении.

### Описание хранимых в коллекции классов:
```java
public class Person {
    private long id; //Значение поля должно быть больше 0, Значение этого поля должно быть уникальным, Значение этого поля должно генерироваться автоматически
    private String name; //Поле не может быть null, Строка не может быть пустой
    private Coordinates coordinates; //Поле не может быть null
    private java.time.ZonedDateTime creationDate; //Поле не может быть null, Значение этого поля должно генерироваться автоматически
    private Integer height; //Поле не может быть null, Значение поля должно быть больше 0
    private EyeColor eyeColor; //Поле не может быть null
    private HairColor hairColor; //Поле не может быть null
    private Country nationality; //Поле может быть null
    private Location location; //Поле не может быть null
}

public class Coordinates {
    private float x; //Максимальное значение поля: 737
    private double y; //Максимальное значение поля: 113
}

public class Location {
    private Float x; //Поле не может быть null
    private Float y; //Поле не может быть null
    private String name; //Длина строки не должна быть больше 889, Поле может быть null
}

public enum EyeColor {
    GREEN,
    YELLOW,
    WHITE;
}

public enum HairColor {
    GREEN,
    BLACK,
    ORANGE,
    WHITE;
}

public enum Country{
    RUSSIA,
    UNITED_KINGDOM,
    ITALY;
}

```
